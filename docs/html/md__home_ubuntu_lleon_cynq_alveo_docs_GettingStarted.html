<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CYNQ: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CYNQ
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Framework to develop FPGA applications in C++ with the easiness of PYNQ</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_ubuntu_lleon_cynq_alveo_docs_GettingStarted.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>CYNQ is as straight-forward as PYNQ. The philosophy behind CYNQ is to be as simple as PYNQ.</p>
<h1>Xilinx K26 SoM</h1>
<p>1) The first step to integrate CYNQ is to include the header:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;cynq/cynq.hpp&gt;</div>
</div><!-- fragment --><p>2) Create an IHardware object to generate the proper drivers for handling the accelerator, data mover and memory. It uses the <code>IHardware::Create(impl, bitstream, xclbin)</code> factory. For instance:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto impl = cynq::HardwareArchitecture::UltraScale;</div>
<div class="line">auto platform = </div>
<div class="line">    cynq::IHardware::Create(impl, bitstream, xclbin);</div>
</div><!-- fragment --><p>where:</p>
<ul>
<li><code>impl</code> is the HardwareArchitecture. At the moment, only <code>UltraScale</code> is supported for UltraScale MPSoC.</li>
<li><code>bitstream</code> is the path to the .bit file (bitstream)</li>
<li><code>xclbin</code> is the path to the .xclbin file. You can use the one in <code>third-party/resources/default.xclbin</code>.</li>
</ul>
<p>3) Create the DMA instances to move the data. This is intended for designs that use AXI4-Stream.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">constexpr int kDmaAddress = 0xa0010000;</div>
<div class="line">auto dma = platform-&gt;GetDataMover(kDmaAddress);</div>
</div><!-- fragment --><p>where <code>kDmaAddress</code> is the address of the DMA instance we want to control. This is given by the design.</p>
<p>4) Create the IP core instances to interact with them.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">constexpr int kAccelAddress = 0xa0000000;</div>
<div class="line">auto accel = platform-&gt;GetAccelerator(kAccelAddress);</div>
</div><!-- fragment --><p>where <code>kAccelAddress</code> is the AXI4-Lite control port of the IP core. As a requirement:</p>
<blockquote class="doxtable">
<p>The IP Cores must have an AXI4-Lite port as a control port </p>
</blockquote>
<p>5) Get buffers to exchange data. These buffers are usually dual memory mapped into host and device regions (physically contiguous).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::size_t input_size = 64; // bytes</div>
<div class="line">std::size_t output_size = 64; // bytes</div>
<div class="line">auto type = MemoryType::Dual; // dual memory</div>
<div class="line"> </div>
<div class="line">auto in_mem = dma-&gt;GetBuffer(input_size, type);</div>
<div class="line">auto out_mem = dma-&gt;GetBuffer(output_size, type);</div>
</div><!-- fragment --><p>where the <code>GetBuffer()</code> method includes: <code>size</code> in bytes and <code>type</code> of the memory type:</p>
<ul>
<li><code>cynq::MemoryType::Dual</code>: allocates two memory regions, one accessible from host and another from device.</li>
<li><code>cynq::MemoryType::Cacheable</code>: allocates a cacheable memory region.</li>
<li><code>cynq::MemoryType::Host</code>: allocates a host-only memory.</li>
<li><code>cynq::MemoryType::Device</code>: allocates a device-only memory.</li>
</ul>
<p>6) To access the data from the memory buffers, you can use the <code>HostAddress</code> method.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">using DataType = uint64_t;</div>
<div class="line">DataType* A = in_mem-&gt;HostAddress&lt;DataType&gt;().get();</div>
<div class="line"> </div>
<div class="line">A[5] = 1;</div>
</div><!-- fragment --><p>The <code>HostAddress&lt;T&gt;()</code> maps the memory into a pointer that is accessible to the host. <code>T</code> can be any type that can be reinterpretedly casted.</p>
<p>7) Write/Read the IP Core / Accelerator registers. You can use the <code>Write()</code> and <code>Read()</code> methods for AXI4-Lite interfaces.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">uint16_t input_a_cols;</div>
<div class="line"> </div>
<div class="line">// Read a single element</div>
<div class="line">accel-&gt;Read(0x20, &amp;input_a_cols, 1);</div>
<div class="line"> </div>
<div class="line">// Write a single element</div>
<div class="line">input_a_cols = 64;</div>
<div class="line">accel-&gt;Write(0x28, &amp;input_a_cols, 1);</div>
</div><!-- fragment --><p>Both <code>Read(addr, data*, elems)</code> and <code>Write(addr, data*, elems)</code> have the same arguments:</p>
<ul>
<li><code>addr</code>: offset address of the register</li>
<li><code>data*</code>: data pointer to be read/written</li>
<li><code>elems</code>: number of elements of type <code>data</code> to read/write</li>
</ul>
<p>Moreover, if you need to attach a memory block to an AXI4 Memory Mapped interface whose address is defined in ab AXI4-Lite interface, you can use the Attach(addr, buffer).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">uint32_t addr = 0x40</div>
<div class="line">accel-&gt;Attach(addr, mem_bo);</div>
</div><!-- fragment --><p><code>Attach(addr, data)</code> arguments:</p>
<ul>
<li><code>addr</code>: memory address offset in the AXI4-Lite control register bank.</li>
<li><code>mem</code>: memory buffer to attach (<code>std::shared_ptr&lt;IMemory&gt;</code>)</li>
</ul>
<p><b>New!</b>: You can use attach also for parameters instead of using <code>Write()</code>/<code>Read()</code>:</p>
<p>For read-only (from the accelerator BAR):</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">accel-&gt;Attach(0x20, &amp;input_a_cols, RegisterAccess::RO, 1);</div>
</div><!-- fragment --><p>or for write-only (also from the accelerator BAR):</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">accel-&gt;Attach(0x28, &amp;input_a_cols, RegisterAccess::RO, 1);</div>
</div><!-- fragment --><p>The <code>Attach(addr, data, type, elems)</code> arguments are:</p>
<ul>
<li><code>addr</code>: memory address offset in the AXI4-Lite control register bank.</li>
<li><code>data</code>: pointer to host memory where the register's values are held.</li>
<li><code>type</code>: type of transfer (see cynq::RegisterAccess)</li>
<li><code>elems</code>: number of elements of type of data (the memory must be 32-bit aligned).</li>
</ul>
<p>Important:</p>
<p>The registers are written only when the <code>IAccelerator::Start</code> is invoked. This does not apply to <code>StartMode::Continuous</code> since the writes only happen every invocation of the <code>IAccelerator::Start</code> method. The registers are read back when invoking IAccelerator::Stop&lt;tt&gt;orIAccelerator::Sync`.</p>
<p>8) Start/Stop the accelerator by writing the control register</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">accel-&gt;Start(StartMode::Continuous);</div>
<div class="line"> </div>
<div class="line">accel-&gt;Stop();</div>
</div><!-- fragment --><p>To start the accelerator, you can use the <code>Start()</code> method, which receives either of the following values:</p>
<ul>
<li><code>cynq::StartMode::Once</code>: turns on the accelerator</li>
<li><code>cynq::StartMode::Continuous</code>: turns on the accelerator in auto-restart mode.</li>
</ul>
<p>9) Transferring information requires the synchronisation of the memory buffers and the interaction with the data mover / DMA.</p>
<p>The data mover is used to upload the data to the AXI4-Stream or download from it.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Upload: requires the buffer to be sync in HostToDevice</div>
<div class="line">dma-&gt;Upload(in_mem, in_mem-&gt;Size(), 0, ExecutionType::Sync);</div>
<div class="line">// Download: after its completion, the buffer must be sync DeviceToHost</div>
<div class="line">dma-&gt;Download(out_mem, out_mem-&gt;Size(), 0, ExecutionType::Sync);</div>
</div><!-- fragment --><p>Both methods take: <code>(memory, size, offset, execution_type)</code>, where <code>size</code> is the amount of data to transfer in bytes, <code>offset</code> moves the starting point of the data and <code>execution_type</code> is the type of execution:</p>
<ul>
<li><code>cynq::ExecutionType::Sync</code>: synchronous mode</li>
<li><code>cynq::ExecutionType::Async</code>: asynchronous mode</li>
</ul>
<p>10) The disposal is done automatically thanks to C++ RAII.</p>
<h1>Alveo Cards or XRT-based platforms with Vitis workflow</h1>
<p>1) The first step to integrate CYNQ is to include the header:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;cynq/cynq.hpp&gt;</div>
</div><!-- fragment --><p>2) Create an IHardware object to create the proper drivers for handling the accelerator, data mover and memory. It uses the <code>IHardware::Create(impl, bitstream, xclbin)</code> factory. For instance:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto impl = cynq::HardwareArchitecture::Alveo;</div>
<div class="line">auto platform = </div>
<div class="line">    cynq::IHardware::Create(impl, &quot;&quot;, xclbin);</div>
</div><!-- fragment --><p>where:</p>
<ul>
<li><code>impl</code> is the HardwareArchitecture. At the moment, only <code>UltraScale</code> is supported for UltraScale MPSoC.</li>
<li><code>xclbin</code> is the path to the .xclbin file. You can use the one in <code>third-party/resources/alveo-xclbin/vadd.xclbin</code>.</li>
</ul>
<p>3) Create the DMA instances to move the data. This is intended for designs that use AXI4-Stream.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto dma = platform-&gt;GetDataMover(0);</div>
</div><!-- fragment --><p>where <code>0</code> is a dummy value, and it is currently unused in this implementation.</p>
<p>4) Create the IP core instances to interact with them.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto accel = platform-&gt;GetAccelerator(&quot;vadd&quot;);</div>
</div><!-- fragment --><p>where <code>"vadd"</code> is the kernel compiled with <code>v++</code>. It is based on the following kernel: [vadd.cpp](<a href="https://github.com/Xilinx/Vitis_Accel_Examples/blob/2022.1/host_xrt/hello_world_xrt/src/vadd.cpp">https://github.com/Xilinx/Vitis_Accel_Examples/blob/2022.1/host_xrt/hello_world_xrt/src/vadd.cpp</a>]</p>
<p>5) Get buffers to exchange data. These buffers are usually dual memory mapped into host and device regions (physically contiguous).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::size_t vec_size = sizeof(int) * kDataSize;</div>
<div class="line">auto type = MemoryType::Dual;</div>
<div class="line">auto bo_0 = mover-&gt;GetBuffer(vec_size, accel-&gt;GetMemoryBank(0), type);;</div>
</div><!-- fragment --><p>where the <code>GetBuffer()</code> method includes: <code>size</code> in bytes and <code>type</code> of the memory type:</p>
<ul>
<li><code>cynq::MemoryType::Dual</code>: allocates two memory regions, one accessible from host and another from device.</li>
<li><code>cynq::MemoryType::Cacheable</code>: allocates a cacheable memory region.</li>
<li><code>cynq::MemoryType::Host</code>: allocates a host-only memory.</li>
<li><code>cynq::MemoryType::Device</code>: allocates a device-only memory.</li>
</ul>
<p>6) To access the data from the memory buffers, you can use the <code>HostAddress</code> method.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">auto bo_0_map = bo_0-&gt;HostAddress&lt;int&gt;().get();</div>
<div class="line">bo_0_map[5] = 1;</div>
</div><!-- fragment --><p>The <code>HostAddress&lt;T&gt;()</code> maps the memory into a pointer that is accessible to the host. <code>T</code> can be any type that can be reinterpretedly casted.</p>
<p>7) Write/Read the IP Core / Accelerator registers. You can use the <code>Attach()</code> method.</p>
<p>If you must attach a memory to an AXI4 Memory Mapped interface, you can instantiate the IMemory pointer through Attach(index, buffer).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">accel-&gt;Attach(0, bo_0);</div>
</div><!-- fragment --><p><code>Attach(index, data)</code> arguments:</p>
<ul>
<li><code>index</code>: argument position</li>
<li><code>mem</code>: memory buffer to attach</li>
</ul>
<p>If you require to attach an argument that is either a scalar or an array in AXI4-Lite interfaces, you can also use Attach(index, data*, n), where:</p>
<ul>
<li>index: position of the argument in the kernel</li>
<li>data: scalar or array pointer</li>
<li>n: number of elements</li>
</ul>
<p>For example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">uint datasize = 4096;</div>
<div class="line">accel-&gt;Attach(3, &amp;datasize);</div>
</div><!-- fragment --><p>8) Upload data</p>
<p>The data upload is done through the data mover:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">mover-&gt;Upload(bo_0, bo_0-&gt;Size(), 0, ExecutionType::Async);</div>
</div><!-- fragment --><p>the <code>Upload(mem, size, offset, execution_type)</code> function is used to upload data from host to device where the arguments are:</p>
<ul>
<li>mem: memory buffer of type <code>std::shared_ptr&lt;IMemory&gt;</code></li>
<li>size: size in bytes</li>
<li>offset: starting point of the buffer</li>
<li>execution_type: synchronisation type<ul>
<li><code>cynq::ExecutionType::Sync</code>: synchronous mode</li>
<li><code>cynq::ExecutionType::Async</code>: asynchronous mode</li>
</ul>
</li>
</ul>
<p>9) Start/Stop the accelerator by writing the control register</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">accel-&gt;Start(StartMode::Once);</div>
<div class="line">accel-&gt;Sync();</div>
</div><!-- fragment --><p>To start the accelerator, you can use the <code>Start()</code> method, which receives either of the following values:</p>
<ul>
<li><code>cynq::StartMode::Once</code>: turns on the accelerator</li>
<li><code>cynq::StartMode::Continuous</code>: turns on the accelerator in auto-restart mode (not supported in Alveo).</li>
</ul>
<p>10) Download data</p>
<p>The data download is done through the data mover:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">mover-&gt;Download(bo_0, bo_0-&gt;Size(), 0, ExecutionType::Sync);</div>
</div><!-- fragment --><p>the <code>Download(mem, size, offset, execution_type)</code> function is used to download data from host to device where the arguments are:</p>
<ul>
<li>mem: memory buffer of type <code>std::shared_ptr&lt;IMemory&gt;</code></li>
<li>size: size in bytes</li>
<li>offset: starting point of the buffer</li>
<li>execution_type: synchronisation type<ul>
<li><code>cynq::ExecutionType::Sync</code>: synchronous mode</li>
<li><code>cynq::ExecutionType::Async</code>: asynchronous mode</li>
</ul>
</li>
</ul>
<p>11) The disposal is done automatically, thanks to C++ RAII. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
