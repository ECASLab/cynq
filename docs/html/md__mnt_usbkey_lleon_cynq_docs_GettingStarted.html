<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CYNQ: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CYNQ
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
   <div id="projectbrief">Framework to develop FPGA applications in C++ with the easiness of PYNQ</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__mnt_usbkey_lleon_cynq_docs_GettingStarted.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>CYNQ is as straight-forward as PYNQ. The philosophy behind CYNQ is to be as simple as PYNQ.</p>
<h1>Xilinx K26 SoM</h1>
<p>1) The first step to integrate CYNQ is to include the header:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cynq/cynq.hpp&gt;</span></div>
</div><!-- fragment --><p>2) Create an IHardware object to generate the proper drivers for handling the accelerator, data mover and memory. It uses the <code>IHardware::Create(impl, bitstream, xclbin)</code> factory. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> impl = cynq::HardwareArchitecture::UltraScale;</div>
<div class="line"><span class="keyword">auto</span> platform = </div>
<div class="line">    <a class="code" href="classcynq_1_1IHardware.html#ab3cc41fbed5a6da306d8ae51153a3065">cynq::IHardware::Create</a>(impl, bitstream, xclbin);</div>
<div class="ttc" id="aclasscynq_1_1IHardware_html_ab3cc41fbed5a6da306d8ae51153a3065"><div class="ttname"><a href="classcynq_1_1IHardware.html#ab3cc41fbed5a6da306d8ae51153a3065">cynq::IHardware::Create</a></div><div class="ttdeci">static std::shared_ptr&lt; IHardware &gt; Create(const HardwareArchitecture hw, const std::string &amp;bitstream, const std::string &amp;xclbin)</div><div class="ttdoc">Create method Factory method to create a hardware-specific subclasses for accelerators and data mover...</div><div class="ttdef"><b>Definition:</b> hardware.cpp:15</div></div>
</div><!-- fragment --><p>where:</p>
<ul>
<li><code>impl</code> is the HardwareArchitecture. At the moment, only <code>UltraScale</code> is supported for UltraScale MPSoC.</li>
<li><code>bitstream</code> is the path to the .bit file (bitstream)</li>
<li><code>xclbin</code> is the path to the .xclbin file. You can use the one in <code>third-party/resources/default.xclbin</code>.</li>
</ul>
<p>3) Create the DMA instances to move the data. This is intended for designs that use AXI4-Stream.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> kDmaAddress = 0xa0010000;</div>
<div class="line"><span class="keyword">auto</span> dma = platform-&gt;GetDataMover(kDmaAddress);</div>
</div><!-- fragment --><p>where <code>kDmaAddress</code> is the address of the DMA instance we want to control. This is given by the design.</p>
<p>4) Create the IP core instances to interact with them.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> kAccelAddress = 0xa0000000;</div>
<div class="line"><span class="keyword">auto</span> accel = platform-&gt;GetAccelerator(kAccelAddress);</div>
</div><!-- fragment --><p>where <code>kAccelAddress</code> is the AXI4-Lite control port of the IP core. As a requirement:</p>
<blockquote class="doxtable">
<p>The IP Cores must have an AXI4-Lite port as a control port </p>
</blockquote>
<p>5) Get buffers to exchange data. These buffers are usually dual memory mapped into host and device regions (physically contiguous).</p>
<div class="fragment"><div class="line">std::size_t input_size = 64; <span class="comment">// bytes</span></div>
<div class="line">std::size_t output_size = 64; <span class="comment">// bytes</span></div>
<div class="line"><span class="keyword">auto</span> type = MemoryType::Dual; <span class="comment">// dual memory</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> in_mem = dma-&gt;GetBuffer(input_size, type);</div>
<div class="line"><span class="keyword">auto</span> out_mem = dma-&gt;GetBuffer(output_size, type);</div>
</div><!-- fragment --><p>where the <code>GetBuffer()</code> method includes: <code>size</code> in bytes and <code>type</code> of the memory type:</p>
<ul>
<li><code>cynq::MemoryType::Dual</code>: allocates two memory regions, one accessible from host and another from device.</li>
<li><code>cynq::MemoryType::Cacheable</code>: allocates a cacheable memory region.</li>
<li><code>cynq::MemoryType::Host</code>: allocates a host-only memory.</li>
<li><code>cynq::MemoryType::Device</code>: allocates a device-only memory.</li>
</ul>
<p>6) To access the data from the memory buffers, you can use the <code>HostAddress</code> method.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> DataType = uint64_t;</div>
<div class="line">DataType* A = in_mem-&gt;HostAddress&lt;DataType&gt;().get();</div>
<div class="line"> </div>
<div class="line">A[5] = 1;</div>
</div><!-- fragment --><p>The <code>HostAddress&lt;T&gt;()</code> maps the memory into a pointer that is accessible to the host. <code>T</code> can be any type that can be reinterpretedly casted.</p>
<p>7) Write/Read the IP Core / Accelerator registers. You can use the <code>Write()</code> and <code>Read()</code> methods for AXI4-Lite interfaces.</p>
<div class="fragment"><div class="line">uint16_t input_a_cols;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read a single element</span></div>
<div class="line">accel-&gt;Read(0x20, &amp;input_a_cols, 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write a single element</span></div>
<div class="line">input_a_cols = 64;</div>
<div class="line">accel-&gt;Write(0x28, &amp;input_a_cols, 1);</div>
</div><!-- fragment --><p>Both <code>Read(addr, data*, elems)</code> and <code>Write(addr, data*, elems)</code> have the same arguments:</p>
<ul>
<li><code>addr</code>: offset address of the register</li>
<li><code>data*</code>: data pointer to be read/written</li>
<li><code>elems</code>: number of elements of type <code>data</code> to read/write</li>
</ul>
<p>Moreover, if you need to attach a memory block to an AXI4 Memory Mapped interface whose address is defined in ab AXI4-Lite interface, you can use the Attach(addr, buffer).</p>
<div class="fragment"><div class="line">uint32_t addr = 0x40</div>
<div class="line">accel-&gt;Attach(addr, mem_bo);</div>
</div><!-- fragment --><p><code>Attach(addr, data)</code> arguments:</p>
<ul>
<li><code>addr</code>: memory address offset in the AXI4-Lite control register bank.</li>
<li><code>mem</code>: memory buffer to attach (<code>std::shared_ptr&lt;IMemory&gt;</code>)</li>
</ul>
<p><b>New!</b>: You can use attach also for parameters instead of using <code>Write()</code>/<code>Read()</code>:</p>
<p>For read-only (from the accelerator BAR):</p>
<div class="fragment"><div class="line">accel-&gt;Attach(0x20, &amp;input_a_cols, RegisterAccess::RO, 1);</div>
</div><!-- fragment --><p>or for write-only (also from the accelerator BAR):</p>
<div class="fragment"><div class="line">accel-&gt;Attach(0x28, &amp;input_a_cols, RegisterAccess::RO, 1);</div>
</div><!-- fragment --><p>The <code>Attach(addr, data, type, elems)</code> arguments are:</p>
<ul>
<li><code>addr</code>: memory address offset in the AXI4-Lite control register bank.</li>
<li><code>data</code>: pointer to host memory where the register's values are held.</li>
<li><code>type</code>: type of transfer (see cynq::RegisterAccess)</li>
<li><code>elems</code>: number of elements of type of data (the memory must be 32-bit aligned).</li>
</ul>
<p>Important:</p>
<p>The registers are written only when the <code>IAccelerator::Start</code> is invoked. This does not apply to <code>StartMode::Continuous</code> since the writes only happen every invocation of the <code>IAccelerator::Start</code> method. The registers are read back when invoking IAccelerator::Stop&lt;tt&gt;orIAccelerator::Sync`.</p>
<p>8) Start/Stop the accelerator by writing the control register</p>
<div class="fragment"><div class="line">accel-&gt;Start(StartMode::Continuous);</div>
<div class="line"> </div>
<div class="line">accel-&gt;Stop();</div>
</div><!-- fragment --><p>To start the accelerator, you can use the <code>Start()</code> method, which receives either of the following values:</p>
<ul>
<li><code>cynq::StartMode::Once</code>: turns on the accelerator</li>
<li><code>cynq::StartMode::Continuous</code>: turns on the accelerator in auto-restart mode.</li>
</ul>
<p>9) Transferring information requires the synchronisation of the memory buffers and the interaction with the data mover / DMA.</p>
<p>The data mover is used to upload the data to the AXI4-Stream or download from it.</p>
<div class="fragment"><div class="line"><span class="comment">// Upload: requires the buffer to be sync in HostToDevice</span></div>
<div class="line">dma-&gt;Upload(in_mem, in_mem-&gt;Size(), 0, ExecutionType::Sync);</div>
<div class="line"><span class="comment">// Download: after its completion, the buffer must be sync DeviceToHost</span></div>
<div class="line">dma-&gt;Download(out_mem, out_mem-&gt;Size(), 0, ExecutionType::Sync);</div>
</div><!-- fragment --><p>Both methods take: <code>(memory, size, offset, execution_type)</code>, where <code>size</code> is the amount of data to transfer in bytes, <code>offset</code> moves the starting point of the data and <code>execution_type</code> is the type of execution:</p>
<ul>
<li><code>cynq::ExecutionType::Sync</code>: synchronous mode</li>
<li><code>cynq::ExecutionType::Async</code>: asynchronous mode</li>
</ul>
<p>10) The disposal is done automatically thanks to C++ RAII.</p>
<h2>Clocking</h2>
<p>Since we do not read the .hwh file, we are not aware about the clocks. We require clocks to properly run the accelerators at the right speed. It is possible to fix the PLL divisors through the IHardware::SetClocks method. They are used as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> clocks = platform-&gt;GetClocks();</div>
<div class="line">clocks[0] = 250.f;</div>
<div class="line">platform-&gt;SetClocks(clocks);</div>
</div><!-- fragment --><p>where <code>platform</code> is an <code>IHardware</code> instance and <code>250.f</code> means <code>250 MHz</code>.</p>
<h1>Alveo Cards or XRT-based platforms with Vitis workflow</h1>
<p>1) The first step to integrate CYNQ is to include the header:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cynq/cynq.hpp&gt;</span></div>
</div><!-- fragment --><p>2) Create an IHardware object to create the proper drivers for handling the accelerator, data mover and memory. It uses the <code>IHardware::Create(impl, bitstream, xclbin)</code> factory. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> impl = cynq::HardwareArchitecture::Alveo;</div>
<div class="line"><span class="keyword">auto</span> platform = </div>
<div class="line">    <a class="code" href="classcynq_1_1IHardware.html#ab3cc41fbed5a6da306d8ae51153a3065">cynq::IHardware::Create</a>(impl, <span class="stringliteral">&quot;&quot;</span>, xclbin);</div>
</div><!-- fragment --><p>where:</p>
<ul>
<li><code>impl</code> is the HardwareArchitecture. At the moment, only <code>UltraScale</code> is supported for UltraScale MPSoC.</li>
<li><code>xclbin</code> is the path to the .xclbin file. You can use the one in <code>third-party/resources/alveo-xclbin/vadd.xclbin</code>.</li>
</ul>
<p>3) Create the DMA instances to move the data. This is intended for designs that use AXI4-Stream.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> dma = platform-&gt;GetDataMover(0);</div>
</div><!-- fragment --><p>where <code>0</code> is a dummy value, and it is currently unused in this implementation.</p>
<p>4) Create the IP core instances to interact with them.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> accel = platform-&gt;GetAccelerator(<span class="stringliteral">&quot;vadd&quot;</span>);</div>
</div><!-- fragment --><p>where <code>"vadd"</code> is the kernel compiled with <code>v++</code>. It is based on the following kernel: [vadd.cpp](<a href="https://github.com/Xilinx/Vitis_Accel_Examples/blob/2022.1/host_xrt/hello_world_xrt/src/vadd.cpp">https://github.com/Xilinx/Vitis_Accel_Examples/blob/2022.1/host_xrt/hello_world_xrt/src/vadd.cpp</a>]</p>
<p>5) Get buffers to exchange data. These buffers are usually dual memory mapped into host and device regions (physically contiguous).</p>
<div class="fragment"><div class="line">std::size_t vec_size = <span class="keyword">sizeof</span>(int) * kDataSize;</div>
<div class="line"><span class="keyword">auto</span> type = MemoryType::Dual;</div>
<div class="line"><span class="keyword">auto</span> bo_0 = mover-&gt;GetBuffer(vec_size, accel-&gt;GetMemoryBank(0), type);;</div>
</div><!-- fragment --><p>where the <code>GetBuffer()</code> method includes: <code>size</code> in bytes and <code>type</code> of the memory type:</p>
<ul>
<li><code>cynq::MemoryType::Dual</code>: allocates two memory regions, one accessible from host and another from device.</li>
<li><code>cynq::MemoryType::Cacheable</code>: allocates a cacheable memory region.</li>
<li><code>cynq::MemoryType::Host</code>: allocates a host-only memory.</li>
<li><code>cynq::MemoryType::Device</code>: allocates a device-only memory.</li>
</ul>
<p>6) To access the data from the memory buffers, you can use the <code>HostAddress</code> method.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bo_0_map = bo_0-&gt;HostAddress&lt;<span class="keywordtype">int</span>&gt;().get();</div>
<div class="line">bo_0_map[5] = 1;</div>
</div><!-- fragment --><p>The <code>HostAddress&lt;T&gt;()</code> maps the memory into a pointer that is accessible to the host. <code>T</code> can be any type that can be reinterpretedly casted.</p>
<p>7) Write/Read the IP Core / Accelerator registers. You can use the <code>Attach()</code> method.</p>
<p>If you must attach a memory to an AXI4 Memory Mapped interface, you can instantiate the IMemory pointer through Attach(index, buffer).</p>
<div class="fragment"><div class="line">accel-&gt;Attach(0, bo_0);</div>
</div><!-- fragment --><p><code>Attach(index, data)</code> arguments:</p>
<ul>
<li><code>index</code>: argument position</li>
<li><code>mem</code>: memory buffer to attach</li>
</ul>
<p>If you require to attach an argument that is either a scalar or an array in AXI4-Lite interfaces, you can also use Attach(index, data*, n), where:</p>
<ul>
<li>index: position of the argument in the kernel</li>
<li>data: scalar or array pointer</li>
<li>n: number of elements</li>
</ul>
<p>For example:</p>
<div class="fragment"><div class="line">uint datasize = 4096;</div>
<div class="line">accel-&gt;Attach(3, &amp;datasize);</div>
</div><!-- fragment --><p>8) Upload data</p>
<p>The data upload is done through the data mover:</p>
<div class="fragment"><div class="line">mover-&gt;Upload(bo_0, bo_0-&gt;Size(), 0, ExecutionType::Async);</div>
</div><!-- fragment --><p>the <code>Upload(mem, size, offset, execution_type)</code> function is used to upload data from host to device where the arguments are:</p>
<ul>
<li>mem: memory buffer of type <code>std::shared_ptr&lt;IMemory&gt;</code></li>
<li>size: size in bytes</li>
<li>offset: starting point of the buffer</li>
<li>execution_type: synchronisation type<ul>
<li><code>cynq::ExecutionType::Sync</code>: synchronous mode</li>
<li><code>cynq::ExecutionType::Async</code>: asynchronous mode</li>
</ul>
</li>
</ul>
<p>9) Start/Stop the accelerator by writing the control register</p>
<div class="fragment"><div class="line">accel-&gt;Start(StartMode::Once);</div>
<div class="line">accel-&gt;Sync();</div>
</div><!-- fragment --><p>To start the accelerator, you can use the <code>Start()</code> method, which receives either of the following values:</p>
<ul>
<li><code>cynq::StartMode::Once</code>: turns on the accelerator</li>
<li><code>cynq::StartMode::Continuous</code>: turns on the accelerator in auto-restart mode (not supported in Alveo).</li>
</ul>
<p>10) Download data</p>
<p>The data download is done through the data mover:</p>
<div class="fragment"><div class="line">mover-&gt;Download(bo_0, bo_0-&gt;Size(), 0, ExecutionType::Sync);</div>
</div><!-- fragment --><p>the <code>Download(mem, size, offset, execution_type)</code> function is used to download data from host to device where the arguments are:</p>
<ul>
<li>mem: memory buffer of type <code>std::shared_ptr&lt;IMemory&gt;</code></li>
<li>size: size in bytes</li>
<li>offset: starting point of the buffer</li>
<li>execution_type: synchronisation type<ul>
<li><code>cynq::ExecutionType::Sync</code>: synchronous mode</li>
<li><code>cynq::ExecutionType::Async</code>: asynchronous mode</li>
</ul>
</li>
</ul>
<p>11) The disposal is done automatically, thanks to C++ RAII.</p>
<h1>Using Execution Graphs</h1>
<p>From v0.3, CYNQ integrates execution graphs. Currently, they are based on execution queues as in CUDA (CUDA Stream). The idea is to add asynchronous non-blocking execution to CYNQ to offer more flexibility. Here there are some tips:</p>
<ul>
<li>Create the execution graph from the platform:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stream = platform-&gt;GetExecutionStream(<span class="stringliteral">&quot;mystream&quot;</span>);</div>
</div><!-- fragment --><ul>
<li>Use a stream per accelerator.</li>
</ul>
<p>Thus, you can use the accelerators in parallel without worrying about sequential execution of each accelerator. This can lower your execution time.</p>
<ul>
<li>Avoid having a single accelerator in different streams.</li>
</ul>
<p>Calling an accelerator from different streams may cause race conditions and unexpected behaviours. We are currently working on covering this scenarios so that there are no worries in this matter.</p>
<ul>
<li>Avoid oversynchronisation.</li>
</ul>
<p>You can call asynchronous code within the stream. However, take into account that you may need to synchronise at a certain point. So, IAccelerator::Sync, IDataMover::Sync and IMemory::Sync can be also added to the streams.</p>
<h2>Converting serial code to stream-based parallel code</h2>
<p>Basically, you can code sequentially. If you want to move it to a stream, create a stream and add it to the first argument.</p>
<p>For example:</p>
<p><em>Sequential code:</em></p>
<div class="fragment"><div class="line">matmul-&gt;Write(XMATMUL_CONTROL_ADDR_A_ROWS_DATA, &amp;a_rows, 1);</div>
<div class="line">matmul-&gt;Write(XMATMUL_CONTROL_ADDR_B_COLS_DATA, &amp;b_cols, 1);</div>
<div class="line">matmul-&gt;Write(XMATMUL_CONTROL_ADDR_C_COLS_DATA, &amp;c_cols, 1);</div>
<div class="line">buf_mem_mm_a-&gt;Sync(SyncType::HostToDevice);</div>
<div class="line">buf_mem_mm_b-&gt;Sync(SyncType::HostToDevice);</div>
<div class="line">matmul-&gt;Start(StartMode::Once);</div>
<div class="line">matmul-&gt;Sync();</div>
<div class="line">buf_mem_mm_c-&gt;Sync(SyncType::DeviceToHost);</div>
</div><!-- fragment --><p><em>Stream code:</em></p>
<div class="fragment"><div class="line">matmul-&gt;Write(stream, XMATMUL_CONTROL_ADDR_A_ROWS_DATA, &amp;a_rows, 1);</div>
<div class="line">matmul-&gt;Write(stream, XMATMUL_CONTROL_ADDR_B_COLS_DATA, &amp;b_cols, 1);</div>
<div class="line">matmul-&gt;Write(stream, XMATMUL_CONTROL_ADDR_C_COLS_DATA, &amp;c_cols, 1);</div>
<div class="line">buf_mem_mm_a-&gt;Sync(stream, SyncType::HostToDevice);</div>
<div class="line">buf_mem_mm_b-&gt;Sync(stream, SyncType::HostToDevice);</div>
<div class="line">matmul-&gt;Start(stream, StartMode::Once);</div>
<div class="line">matmul-&gt;Sync(stream);</div>
<div class="line">buf_mem_mm_c-&gt;Sync(stream, SyncType::DeviceToHost);</div>
</div><!-- fragment --><p>Examples: zynq-mpsoc/ad08-sequential.cpp, zynq-mpsoc/ad08-streams.cpp</p>
<h2>Adding non-CYNQ function to the stream</h2>
<p>You can also add code which is not part of CYNQ. Here is an example:</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> std::atomic_int num{0};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Here is the function to add</span></div>
<div class="line"><a class="code" href="structcynq_1_1Status.html">cynq::Status</a> dummy_function() {</div>
<div class="line">  std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;num: &quot;</span> &lt;&lt; num.load() &lt;&lt; std::endl;</div>
<div class="line">  num++;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="structcynq_1_1Status.html">cynq::Status</a>{};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add your function to the stream</span></div>
<div class="line">stream-&gt;Add(dummy_function);</div>
<div class="ttc" id="astructcynq_1_1Status_html"><div class="ttname"><a href="structcynq_1_1Status.html">cynq::Status</a></div><div class="ttdoc">Structure to define the return characteristics of each function.</div><div class="ttdef"><b>Definition:</b> status.hpp:19</div></div>
</div><!-- fragment --><p>You can also add a function multiple times.</p>
<p>For an example, you can look at structures/execution-stream.cpp. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
